# -*- coding: utf-8 -*-
"""ranker.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A1PuRV7a5G8jABU_C1pVBbq2vzNhSYcM
"""

"""# model creator"""
from typing import List
import tensorflow as tf
import tensorflow_recommenders as tfrs
import matplotlib.pyplot as plt

def model_creator(data,layers:List,phase,saving_filepath)-> tf.keras.Model:

  ages=data.ages
  embedding_dim=data.embedding_dim
  unique_user_gender=data.unique_user_gender
  movie_genres=data.movie_genres
  unique_movie_genres=data.unique_movie_genres
  unique_movie_titles=data.unique_movie_titles
  unique_user_occupation=data.unique_user_occupation
  time_bucket=data.time_bucket
  timestamp=data.timestamp
  user_data=data.user_data
  age_normalizer=tf.keras.layers.Normalization(
      axis=None
  )

  # gender model
  gender_model=tf.keras.Sequential(
      [tf.keras.layers.IntegerLookup(vocabulary=unique_user_gender),
      tf.keras.layers.Embedding(len(unique_user_gender)+1,embedding_dim)
      ]
  )
  # genre model
  genre_normalizer=tf.keras.layers.Normalization(axis=None)

  genre_model=tf.keras.Sequential([tf.keras.layers.IntegerLookup(vocabulary=unique_movie_genres),
      tf.keras.layers.Embedding(len(unique_movie_genres)+1,embedding_dim)
      
      ]
  )
  # movie model
  movie_model=tf.keras.Sequential(
      [tf.keras.layers.StringLookup(vocabulary=unique_movie_titles),
      tf.keras.layers.Embedding(len(unique_movie_titles)+1,embedding_dim)
      ]
  )
  # occupation model
  occupation_model=tf.keras.Sequential(
      [tf.keras.layers.StringLookup(vocabulary=unique_user_occupation),
      tf.keras.layers.Embedding(len(unique_user_occupation)+1,embedding_dim)
      ]
  )

  # time normalizer
  time_model=tf.keras.Sequential(
      [tf.keras.layers.Discretization(time_bucket.tolist()),
      tf.keras.layers.Embedding(len(time_bucket)+1,embedding_dim)
      ]
  )
  time_normalizer=tf.keras.layers.Normalization(axis=None)
  # rating model
  rating_model=tf.keras.Sequential(
      [tf.keras.layers.Dense(128,activation='tanh'),
      tf.keras.layers.Dense(64,activation='tanh'),
      tf.keras.layers.Dense(1) 
      ]
  )
  if phase=='training':
    time_normalizer.adapt(timestamp)
    genre_normalizer.adapt(movie_genres)
    age_normalizer.adapt(ages)

  class UserModel(tf.keras.Model):
    def __init__(self):
      super().__init__()
      self.age_normalizer=age_normalizer
      self.gender_model=gender_model
      self.occupation_model=occupation_model
      self.time_model=time_model
      self.time_normalizer=time_normalizer

    def call(self,inputs):
      out=tf.concat(
          [tf.reshape(self.age_normalizer(inputs['age']),(-1,1)),
          self.gender_model(inputs['gender']),
          self.occupation_model(inputs['occupation']),
          self.time_model(inputs['time']),
          tf.reshape(self.time_normalizer(inputs['time']),(-1,1))
          ],axis=1
      )
      return out
  class QueryTower(tf.keras.Model):
    def __init__(self,layers):
      super().__init__()
      self.user_model=UserModel()
      self.dense_model=tf.keras.Sequential()
      for layer in layers[:-1]:
        self.dense_model.add(tf.keras.layers.Dense(layer,activation='relu'))
      for layer in layers[-1:]:
        self.dense_model.add(tf.keras.layers.Dense(layer,activation='relu'))
    def call(self,inputs):
      v=self.user_model(inputs)
      return self.dense_model(v)
  class MovieModel(tf.keras.Model):
    def __init__(self):
      super().__init__()
      self.movie_model=movie_model
      self.genre_model=genre_model
      self.genre_normalizer=genre_normalizer
    def call(self,inputs):
      out=tf.concat(
          [self.movie_model(inputs['movie_title']),
          self.genre_model(inputs['genre']),
          tf.reshape(self.genre_normalizer(inputs['genre']),(-1,1))
          ],axis=1
      )
      return out
  class CandidateTower(tf.keras.Model):
    def __init__(self,layers):
      super().__init__()
      self.movie_model=MovieModel()
      self.dense=tf.keras.Sequential()
      for layer in layers[:-1]:
        self.dense.add(tf.keras.layers.Dense(layer,activation='relu'))
      for layer in layers[-1:]:
        self.dense.add(tf.keras.layers.Dense(layer))
    def call(self,inputs):
      x=self.movie_model(inputs)
      return self.dense(x)
  class Rating(tf.keras.Model):
    def __init__(self,layers):
      super().__init__()
      self.candidate_tower=CandidateTower(layers)
      self.query_tower=QueryTower(layers)
      self.rating_model=rating_model
    def call(self,inputs):
      candidate_embedings=self.candidate_tower(inputs)
      query_embeddings=self.query_tower(inputs)
      rating_input=tf.concat([candidate_embedings,query_embeddings],axis=1)
      rates=self.rating_model(rating_input)
      return rates

  class Ranker(tfrs.models.Model):
      def __init__(self, layers):
          super(Ranker, self).__init__()
          self.rating_model = Rating(layers)
          self.task = tfrs.tasks.Ranking(
              loss=tf.keras.losses.MeanSquaredError(),
              metrics=[tf.keras.metrics.RootMeanSquaredError()]
          )

      def call(self, inputs):
          rate = self.rating_model(inputs)
          return rate

      def compute_loss(self, features,
                       training=True
                       # Whether the model is in training mode
                       ):
          labels = features.pop('rating')
          pred = self(features)
          return self.task(labels=labels, predictions=pred)
  model = Ranker(layers)
  model.compile(optimizer=tf.keras.optimizers.Adagrad(learning_rate=0.1))
  if phase=='training':

    tf.random.set_seed(123)
    shuffled=data.user_data.shuffle(1_000,reshuffle_each_iteration=False)
    train=shuffled.take(80_000)
    test=shuffled.skip(80_000).take(10_000)
    cached_train = train.shuffle(100_000).batch(2048).cache().prefetch(tf.data.AUTOTUNE)
    cached_test = test.batch(2048).cache().prefetch(tf.data.AUTOTUNE)

    epoches=input('insert epochs number :')
    one_layer_history = model.fit(
    cached_train,
    validation_data=cached_test,
    validation_freq=5,
    epochs=int(epoches),
    verbose=1)
    model.evaluate(cached_test, return_dict=True)
    plt.title('loss')
    plt.plot(one_layer_history.history['loss'])
    plt.show()
    model.save_weights(saving_filepath)
  if phase=='deployment':

      model.load_weights(saving_filepath)

  return model

def get_output(model,data,phase,input_data,recommender_input):
    if phase=='training':
        test_data = [i for i in data.all_data.batch(1).take(10)]
        for test in test_data:
            prediction = model(test)
            actual_label = test['rating']
            movie_title = test['movie_title']
            print('user : one random user')
            print(f' movie : {movie_title}')
            print(f'actual rate is {actual_label}\n predicted rate is {prediction}')
            print('------------------------')
    if phase=='deployment':
        import utility_functions as utilities
        recommender_input=[i for i in recommender_input][0]
        for data_ in input_data:
            prediction=model(data_)
            print('user :')
            print(utilities.user_feature_extractor(recommender_input['user_id'].numpy()[0], data))
            print('target movie :')
            print(data_['movie_title'])
            print('with genre', data_['genre'])
            print('predicted rate ',prediction)

